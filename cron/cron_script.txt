Введення в cron

Огляд: що таке cron, його роль в автоматизації завдань.
що таке крон - ми вже на теоретичних заняттях її розглядали. утілита яка може виконувати задачи за розкладом. особливість розкладів - це файл з кронтаб-рядками.
як він працює зовні. основна реалізація крона, яку дуже давно написав paul vixie працює так. при старті операційїної системи запускається демон. 
як крон парсить ці ? як би ви парсили ці рядки якщо б перед вами стане така задача.
крон робить так, кожної хвилини перевіряє "кронтаби" файли де можуть зберігатися завдання. в сучасних лінуксах це:
- /etc/crontab
прямо з нього виконуються завдання з /etc/cron.hourly  /etc/cron.daily /etc/cron.weekly /etc/cron.monthly тощо та /etc/cron.d/
причому в них окрім таймінгів, є ще ім'я логіну від якого виконується джоб.
ті файли що правляться за допомогою команди crontab -e зберігаються в каталозі /var/spool/cron/crontabs/oleg - з ім'ям юзера в якості імені файла.
що значить перевіряє - це означає що бере номер  поточні номер місяця, дня тижня, місяця, годину, хвилину. точніш бере ці цифри наступної хвилини, і кожну джобу яка є в кронфайлах, чи підпадає вона під умови наступної хвилини. якщо підпадає то планує що через хвилину запустити ці джоби. вираховує скільки потрібно поспати щоб прокинутись наступної хвилини та уходить в сліп.
цей механізм дає достатню точність для хвилин. і якщо ви будете тестувати написання джобів які хочеться щоб відпрацювали якомога скоріше, то от дивиться, зараз 
хх годин, уу хвилин. якщо я поставлю нову таску на уу+1 хвилину, якщо встигну зберігти джобу то вона не запуститься, томущо всі джоби що були заплановані запускатиться в хх уу+1 були вже заплановані на початку поточної хвилини. мені потрібно планувати на 2 хвилини вперед і зберігти змінений крон за 2 хвилини від плану.

раз вже почав про підводні камені крона, то розкажу про ще пару з них.
перше - це в документації сказано 
Percent-signs (%) in the command, unless escaped with backslash (\), will be changed into newline characters, and all data after the first % will be sent to the command as standard input.
але хто того читає. тобто це спецсімвол який дозволяє писати багаторядкові кронджоби, з іншого боку це означає що відсоток - це символ який потрібно екранувати в кронджобах. це може стати несподіванкою в багатьох простих скриптах наприклад date +%F

поперше дефолтний інтепретатор sh - може стати на заваді якщо у вас використовуються "башизми" - синтаксичні конструкції притаманні bash але відсутні в sh. як наприклад [[ ]]  для умов, $(( )) для арифметикі, $RANDOM, масиви. 
ви можете змінити цю поведінку виставивши SHELL=/bin/bash прямо серед списка джобів. джоби нижче цієї директиви будуть виконуватись bash-ем, або явна вказівка яким інтепретатором виконувати скрипт.

далі, змінні середовища cron, і середовище  дуже відрізняються від того що зазвичай є в інтерактивній сессії bash.
особливо це змінні середовища PATH, в 7му редхаті вона дуже обмежено, і раніше було важливо що туди не потрапляв /sbin/ /usr/bin лише /bin 
зараз, в сучасній 22й убунті більшість утілит присутні в обидвах ціх шляхах тому що /bin є посиланнямн на /usr/bin, /sbin на /usr/sbin. і в змінну середовища в PATH додані всі каталоги.
і прямо зараз взагалі йде обговорення в федорі про об'єднання каталогів в єдиний. 


але тим не меньш. в більш старих дистрибутивах можна на це наступити, це вирішується або перевіркою і додаванням шляхів в PATH прямо в скрипті, або повними шляхами до утілит /bin/date, /sbin/ip тощо. чи навпаки можете  успадкувати скрипти з такими запобіжниками.



альтернативи та доповнення крон.
альтернативи, 
зупинятися не буду. це список альтернатив vixie cron для які я отримав з дистрибутива gentoo, я то і знаю про їх існування лише тому що стояв перед вибором який крон обрати в генту:

cronie
Cronie (sys-process/cronie) - це відгалуження від класичного vixie-cron, зроблене дистрибутивом Fedora і все ще підтримується. Ця програма має той же набір можливостей, що й оригінальний vixie-cron. Додатково, cronie має увімкнену за замовчуванням реалізацію anacron. 

dcron (Dillon's Cron)
sys-process/dcron прагне бути простою, елегантною та безпечною реалізацією програми cron. Він не дозволяє інсталювати змінні середовища у файлах crontabs і всі завдання cron запускаються з /bin/sh. Як і vixie-cron, кожен користувач має власний файл завдань crontab. він підтримує anacron-подібні можливості.
Можливості: Швидкий, простий та вільний від зайвих функцій;
Доступ до файлу crontab обмежений групою cron, тобто. він не покладається на зовнішні засоби.

fcron
sys-process/fcron орієнтований те що, щоб замінити собою vixie-cron і anacron. Він розроблений для роботи на системах, які не працюють безперервно і включає додаткові особливості. Він має обмеження на запуск завдань, управління серіалізацією робіт, можливість призначити роботам приємні у користуванні значення та можливість запланувати запуск робіт під час завантаження системи.
Можливості sys-process/fcron:
Розроблено до роботи на системах, які працюють безперервно, тобто. він може запустити завдання після перезапуску, якщо його було пропущено;
встановлення змінних середовища та безлічі інших параметрів у файлах завдань crontab;
Поліпшений синтаксис crontab з підтримкою багатьох нових функцій;
Кожен користувач може мати особистий файл завдань crontab; доступ контролюється файлами cron.allow та cron.deny

bcron
sys-process/bcron - це нова система cron, розроблена з урахуванням безпеки її роботи. Щоб досягти цього, система поділена на кілька окремих програм, кожна з яких відповідає за окреме завдання, із строго контрольованим повідомленням між ними. Інтерфейс користувача є несуттєвою зміною інтерфейсів для подібних систем (таких як vixie-cron), але внутрішні частини програми сильно відрізняються.
Легка заміна vixie-cron;
Орієнтованість на множину процесів;
Нативна підтримка переходу на DST
 
Під windows є nncron https://github.com/nnCron/nnCron (але схоже він вже 9 років як не розвивається). 
До того ж в windows є windows task sсheduler, з доволі потужним графічним інтерфейсом.

Також є споріднена утиліта, яка називається anacron, яка призначена для роботи з cron-ом на системах, які не працюють безперервно.
systemd timers: У системах, які використовують systemd, можна використовувати вбудований механізм таймерів systemd для планування завдань.
at/atq: Утілити для виконання одноразових задач в конкретний час, дата-час, підтримує формат постановки задачи "через 10 хвилин".  розглянемо більш подробно.


Anacron – це утиліта, яка вирішує проблему виконання періодичного завдання на комп'ютерах з непостійною активністю коли cron не є оптимальним вибором. 
Наприклад персональний компьютер який не працює цілодобово і може бути вимкнутий в той час коли за розкладом заплановано виконання. 
це буває окрема утілита або іноді входить як частина реалізації крона, або покладається на нього.
управляється файлом /etc/anacrontab схожим на crontab, але там лише 2 параметра щодо часу:
period  delay  /path/to/job.sh 
period - частота виконання періодичного завдання в днях. 
delay - в хвилинах. можливий діапазон відхилення від запланованого часу старту. типово в зв'язці з кроном працює так - що кожні півгодини перевіряютсья обставини запуску, якщо обставини дозволяють то запускається таска з делаєм. якщо ні - то можливо пощастить наступного разу. 


Ще типовий юзкейс - це задачі які потрибують виконання декілька раз на хвилину. технічно найпростіше це дві або більше рядків в crontab, з затримкою sleep.
зазвичай це цілодобовий постійний скрипт який щось робить швидке.
* * * * * /path/to/script.sh
* * * * * sleep 30 ; /path/to/script.sh
також можна занести цю складність в скрипт, що він буде сам виконуватись декілька разів, кожна підпроцедура з різними паузами.
якщо потрібно частіше ніж "умовні 10 сек" то подивіться на те 


задачи at - це задачи які повинні одноразово виконатись в конкретний час.
sudo apt install at
або задачі які повинні виконатись під час низького навантаження, 

задачі потрібно оформляти у вигляді скрипта що подається на stdin в команду at.
команді at потрібно вказати в який час виконати задачу. це може бути формат HH:MM якщо це час який який ще буде сьогодні - то заплановано буде на сьогодні, якщо він вже пройшов то мається наувазі завтра. можна задати день місяць - точно, за допомогою широкого набіра форматів дати. чи можна не гадати і задавати через поз
-t [[CC]YY]MMDDhhmm[.ss] 


можна задавати скрипти як аргумент -f. але вони будуть виконуватись за допомогою інтепретатора sh.
at -f /path/to/script.sh
'bash /path/to/script.sh' | at  now +1 minute

можна відносний час:
echo 'date > /tmp/example' | at now +2 minute
warning: commands will be executed using /bin/sh
job 1 at Wed Jan  3 01:11:00 2024

echo 'echo' | at 20:00  

echo 'echo' | at 20:00 tomorrow
echo 'echo' | at 20:00 2024-01-03
echo 'echo' | at now +10 minute  # один з найкорисніших варіантів використання.
echo 'echo' | at tomorrow +10 minute
echo 'echo' | at friday    (в такий же час найбличої п'ятниці)
echo 'echo' | at 10:00 friday    (в 10:00 найбличої п'ятниці)

atq/at -l - показує список завдань на майбутнєє
щє є "черги". щось типу неймспейса завдань, для окремих цілей, щоб не заважати іншим завданням. 

Usage: at [-V] [-q x] [-f file] [-u username] [-mMlbv] timespec ...
       at [-V] [-q x] [-f file] [-u username] [-mMlbv] -t time
       at -c job ...
       at [-V] -l [-o timeformat] [job ...]
       atq [-V] [-q x] [-o timeformat] [job ...]
       at [ -rd ] job ...
       atrm [-V] job ...
       batch

в всіх at-командах є опція -q x, де x латинська літера, 
в якості дефолтної назви at -q a
для "батчей" зарезервовано at -q b 
інші літери можна задіяти
(демонстрація atq -q a - показує список джобів, atq -q b,  atq -q c - не показує.)

у мене є реєструєтсья "подія". я хочу через 10 хвилин після початку - "закрити подію", але якщо після початку протягом 10 хвилин ще буде буде зареєструється "подія" то я хочу "продовжити", відмінити закриття тасок і створити новий таймер. для такого я використовував окрему чергу.

atrm - видаляти джоби з черги.
at -c 11  - подивитись інформацію про джобу.  фактично це скрипт який створює змінні середовища такі як зараз. переходить в каталог де ви зараз. і запускає те що ви надали в stdin або в параметрі -f. інтепретатором буде sh. тому або скрипт повинен бути sh (без башизмів) або він повинен викликатись bash-ем. 
дуже прикольно /var/spool/cron/atjobs



todо:
inotify/INCRON


systemd.timer:
вбудований в systemd механізм. потужний, може замінити крон, anacron та at.  
але об'єктами що він запускає є не рядки, а systemd unit-и. хоча вони і створюються нескладно, але потрибують 2 залежних але окремих юнітів .timer та .service 

https://www.freedesktop.org/software/systemd/man/latest/systemd.timer.html

systemctl list-timers
https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html


простий юніт example.timer:
```
[Unit]
Description=Example Timer

[Timer]
OnCalendar=*-*-* *:*:00
Persistent=true

[Install]
WantedBy=timers.target
```


```
[Unit]
Description=Example Service
Wants=example.timer

[Service]
ExecStart=/path/to/script
```

цікавим є параметр OnCalendar=*-*-* *:*:00 який описує "щохвилини"

про цей параметр розповідається в документації в "Calendar Events"
https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html
там можуть бути як "назви" так і нормалізовані графіки.  
тобто *-*-* *:*:00 - це нормалізований *-*-* - описує дати рік, номер місяця, день місяця.
*-*-02 10:00:00 - щомісяця, 2-го числа о десятій. 
може бути діапазони, позначаються через 2 крапочки. (замість тире в кронтабах) 
*-*-01..07 10:00:00 - щомісяця, з першого по 7 числа.

також може бути по дням тиждня.
Mon *-*-* 12:00:00 
Mon,Fri *-*-* 12:00:00

це багато прикладів, в тому числі ненормалізовані, от наприклад як в документації:

    minutely → *-*-* *:*:00
      hourly → *-*-* *:00:00
       daily → *-*-* 00:00:00
     monthly → *-*-01 00:00:00
      weekly → Mon *-*-* 00:00:00
      yearly → *-01-01 00:00:00
   quarterly → *-01,04,07,10-01 00:00:00
semiannually → *-01,07-01 00:00:00

а також використання коли відкидається частина інформації, що означає значення за замовчуванням [як і в ipv6].
                    Wed *-1 → Wed *-*-01 00:00:00
           Wed..Wed,Wed *-1 → Wed *-*-01 00:00:00
                 Wed, 17:48 → Wed *-*-* 17:48:00
Wed..Sat,Tue 12-10-15 1:2:3 → Tue..Sat 2012-10-15 01:02:03
             03-05 08:05:40 → *-03-05 08:05:40  
                   08:05:40 → *-*-* 08:05:40
                      05:40 → *-*-* 05:40:00      
                *-*-7 0:0:0 → *-*-07 00:00:00
                      
щоб все це запрацювало, потрібно створити юніти, увімкнути їх, для цього потрібні рутові права, хоча б через sudo. якщо юзер який хоче створити юніт в юзерському оточенні і не має відповідних прав, то потрібно щоб адміністратор під це налаштував systemd. як на мене вся ця складність при наяві дуже популярної і звичної альтернативі - кронтаб, недивлячись на його недоліки робить цей механізм переускладненим.
наприклад кронтаби - це дефолтний механізм в jenkins джобах що повторюються.
а недоліки.. наприклад вам потрібно запускати джобу "кожної останньої п'ятниці місяця", або навіть кожної першої п'ятниці. скоріш за все це буде кожної п'ятниці а потім в скрипті визначається чи сьогодні остання п'ятниця місяця.


