# ssh

## Before SSH (слайд 2)
до того як став поширений ssh, для роботи remote-консолі в мережі ip/tcp використовували протокол telnet. 
по дефолту він працює на порту 23, має теж саме що ми бачимо по ssh-консолі. навіть продемонструю:
створити юзерів для прикладів:
```
useradd user1
echo '1qazxsw2' | passwd user1 --stdin
useradd user2
echo '2wsxzaq1' | passwd user2 --stdin

yum install telnet-server
firewall-cmd --add-service=telnet --zone=public --permanent 
setenforce permissive
systemctl enable telnet.socket
systemctl start telnet.socket
```

в чому його проблема - в першу чергу це його повна мережева прозорість, всі команди-взаємоія у вигляді plaintext, якщо зловмисник буде мати доступ до каналів - отримає паролі.

## SSH (слайд 3)
в цьому плані ssh вирішує наступні проблеми:
- шифрований канал на між tcp-з'єданням на трафіком всередині. 
- аутентифікація не тількі на рівні того що надає система входу термінал - це форма для вводу логіна та пароля. 
це може також може бути, файлові ключі.
- налаштування, обмеження на рівні логіна, або ключа який використовує клієнт.
- клієнт може запам'ятати fingerprint сервера, та має реакцію на його зміну. 

і надає деякі додаткові можливості :
- передача файлів 
-  remote command call 
хоча це і по телнету була така можливість rsh/scp
- зверху ssh, точніш в середині - тунелювання tcp-з'єдань у різних варіаціях, як просто тунель, так і sock-проксі, прокидання графічних X-сессій (наразі це майже не використовується), автоматизація деяких механізмів.


ssh - це протокол, реалізацій багато. Відрізняються, але найпопулярніша назараз на серверах це openssh - реалізація від спільноти яка розвивала юнікс OpenBSD з особливим поглядом на безпеку (Secure).
На сьогодні це серверне програмне забезпечення яке по дефолту встановлено на серверних дистрибутивах Linux, і є основним інструментом щоб виконувати команди, змінювати налаштування операційної системи, тощо.
Клієнтська частина openssh доступна навість в складі windows 10 з 2018 року.
https://devblogs.microsoft.com/powershell/using-the-openssh-beta-in-windows-10-fall-creators-update-and-windows-server-1709/

## ssh configuration (слайд4)

Так як це клієнт-серверне ПЗ, то на стороні сервера є конфігуація сервера, і хочь клієнт буде на іншому компьютері, дефолтна конфигурація клієнтської частини знаходиться поручь, Відрізняються однією літерою
конфігуація сервера:
`/etc/ssh/sshd_config`

конфігуація клієнта:

`/etc/ssh/ssh_config`
`~/.ssh/config`

Серверний конфиг:
`/etc/ssh/ssh_host_*_key`  - ключі сервера, відповідають на "фінгерпринт".

відмітити
- `PermitRootLogin no` - дефолтна заборона аутентифікації руту по ssh-протоколу.
- `PasswordAuthentication` - заборона використовувати логін-парольний метод аутентифікації
- `AcceptEnv` - змінні середовища які дозволяється прокидувати на сервер:


клієнтский конфиг:
відмітити структуру "Host" та табуляція. 
а також що деякі речі наприклад дефолтні ключі:
```
   IdentityFile ~/.ssh/identity
   IdentityFile ~/.ssh/id_rsa
   IdentityFile ~/.ssh/id_dsa
   IdentityFile ~/.ssh/id_ecdsa
   IdentityFile ~/.ssh/id_ed25519
```
а також приклад:
```
   HashKnownHosts yes
```
та дефолтні параметри, наприклад змінні середовища LANG які прокидуються на сервер. можна продемонструвати

продемонструвати що на центосі локально:
```
[user1@ssh-centos ~]$ echo $LANG
en_US.UTF-8
```

на убунті - локально
```
oleg@ssh-ubuntu:~$ echo $LANG
C.UTF-8
```

але якщо залогінитись з убунти на центос:

```
ssh-ubuntu:~$ ssh user1@ssh-centos 
user1@ssh-centos's password: 
Last login: Thu Jan 11 19:20:41 2024
[user1@ssh-centos ~]$ echo $LANG
C.UTF-8
```

як бачим LANG відрізняється від дефолтного, тобто прокидувався. 

## Key based auth (слайд 5)

Одна з найпопулярніших особливостей ssh - це його pubkey-аутентифікації.
як це працює:

створюється пара ключей. приватний та публічний 
```
ssh-keygen -t type -b bits  -f filename -C comment  -P passphrase
```

щодо passphrase про це буде окрема розповідь.
тип - це `rsa | ecdsa | ed25519 | dsa`  дефолтно rsa.

## Key based auth (слайд 6)
далі необхідна частина це додавання ключа на сервер: будьякий спосіб, для автоматизації є утілита `ssh-copy-id`
 
client: `ssh-copy-id -i filename username@remote_host ` - якщо файл не заданий - він скопіює id_rsa.pub якщо ви вкажете приватний ключ, утілита спробує знайти відповідний pub-кей.
запитає пароль, якщо ви його звісно знаєте.

результатом цієї дій є створення на сервері у відповіддного юзера каталога ~/.ssh/ та файла   ~/.ssh/authorized_keys
однією особливістью є права каталога та файла. 700 на каталог, 600 на файл - продемонструвати. 


Аутентифікація:
`client: ssh -i path/to/privatekey username@remote_host`
Дефолтне значення `~/.ssh/id_rsa`
після першого коннекту до ssh-сервера - ми отримуємо попередження

оглянути man ssh, ключі 
```
-p порт
-l login
-o опції. 
```

## ssh fingerprint
ssh-HashKnownHosts
пам'ятаєете при створенні ключа був продемонстрований `fingerprint` ключа.

при першому приєданні до сервера 
```
oleg@ssh-ubuntu:~$ ssh -i examplekey -l user1 ssh-centos
The authenticity of host 'ssh-centos (10.166.0.3)' can't be established.
ED25519 key fingerprint is SHA256:xhe1YaLE//g8NWIrm34GVCLzW+18nfiBBxDvt0I04nU.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```

```
ssh-keygen -l -f ssh_host_ed25519_key 
256 SHA256:xhe1YaLE//g8NWIrm34GVCLzW+18nfiBBxDvt0I04nU root@ssh-centos (ED25519)
```

продемонструвати що публичну частина ключа сервера клієнт сберіг собі в файл `~/.ssh/known_hosts`
можливо показати як це відбувається якщо не хешувати ключ.

змінити цей параметр `/etc/ssh/ssh_config
```
 HashKnownHosts no
```

потім аналогічно продемонструвати що параметр можна задати опцією `-o`
```
ssh -o HashKnownHosts=no -i examplekey -l user1 10.166.0.3
```

потім показати що ключ можна замінити на сервері:
```
ssh-keygen  -t ed25519 -f /etc/ssh/ssh_host_ed25519_key
```

і показати помилку фінгерпринта якщо це зміниться

що це можна ігнорувати:
```
ssh -o StrictHostKeyChecking=no -i examplekey -l user1 ssh-centos
```
що це можна виправити видаливши  застарілий фінгерпринт
```
ssh -o StrictHostKeyChecking=accept-new -i examplekey -l user1 ssh-centos
```

а також часто використовуваний трюк з указанням `/dev/null` в якості файла та 
```
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i examplekey -l user1 ssh-centos
```

## ~/.ssh/config (слайд 8)
для автоматизації задач щоб не стопорилось все на обробку цього фінгерпринта.
опції  `-o` та  конфіг `~/.ssh/config`
```
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i examplekey -l user1 ssh-centos
```

це конфіг-файли, які дозволяють запа'ятовувати налаштування "дефолтні" або дефолтні в рамках хоста/хостів.
```
CheckHostIp no
GSSAPIAuthentication no
IdentityFile ~/.ssh/default_key

Host hostalias
  HostName realhost_ip
  User user1
  Port     2222
  IdentityFile ~/.ssh/custom_key
  UserKnownHostsFile=/dev/null
  StrictHostKeyChecking=no

$ ssh hostalias
```

ми можемо замінювати деякі частини конфігу, наприклад логін. 
секції. можуть описувати хости. може описувати за маскою:
```
Host 172.16.*
  User ec2
  IdentityFile ~/.ssh/ec2_key
  
Host jumphost 
  User user1
  IdentityFile ~/.ssh/id_rsa
 
Host 192.168.*
  ProxyCommand ssh jumphost -W %h:%p
  User root
  IdentityFile ~/.ssh/ec2_key
```

## verbose logging (слайд 9)
Відладка:
якщо з якоїсь причини у вас не получається автоматизавувати з'єднання, наприклад те саме беспарольне, або заміть використання ключа запитує пароль - то прийшов час дебажити.
щоб дебажити на стороні клієньа достатньо використати ключ -v 
продемонструвати роботу ssh -v успішну, та замінювати
а також наприклад як працює ssh -v hostalias по конфигу. 

логи на стороні сервера - це переважно логи в /var/log/secure rhel-based /var/log/auth.log в debian-based дистрибутивах.

їх детальність визачаєтсья параметрами: 
`/etc/ssh/sshd_config:`
параметр `LogLevel INFO`
може приймати параметри 
`INFO, VERBOSE, DEBUG`
може більше, в документації. але цього достатньо для дебага таких розповсюджених помилок як права на файли з ключами, 

## scp (слайд 10)
функціонал копіювання файлів. 

`scp` – ssh copy. це було і для телнету, відповідні утілити rcp, але це по ссш каналу.
основний синтаксис: 
```
scp localfile remote:file
scp remote:file localfile 
```

можна копіювати з одного remote на інший,
```scp remote1:file remote2:localfile ```
але тут уважно, це це буде копіювати з `remote1` -> `remote2`, тому для такого необіхдно задати налаштування доступу на хості remote1 так щоб він зміг з'єднатись з remote2

популярні опції саме `scp`:
```scp -p -r ...
-p permission
-r recursive
```

і так як це openssh-client, то від підтримує більшість параметрів що підтримує ssh, автоматично викоритовує налаштування `~/.ssh/config`, можна викоритосвувати опції `-o` , ключі `-i` тощо. 
в синтаксисі `remote` вже використовується `:` тому альтернативний порт казується не за допомогою `:22`, а опцією `-P` про це написано в документації.

```rsync ~/localdir/ user@192.168.56.100:/remote/dir```
першоначально використовував свій порт та протокол (досі підтримується), 
`grep rsync /etc/services`
дозволяє копіювати рекурсивно каталоги, з гнучкими стратегіями синхронізації  "перезапису, лише оновлення, видалення того що було видалено на джерелі" навіть вміє копіювати частину файла що була змінена, а не весь файл.
саме rsync  протокол, який дозволяє анонімний доступ як і ftp, http, часто використовувався як транспортний для підтримання дзеркал репозиторіїв наприклад.
але після того як ssh став стандартом remote shell, то копіювання поверх ssh в rsync вбудовано на рівні підтримки опцій openssh. 
```
rsync [OPTION...] [USER@]HOST:SRC... [DEST]
rsync [OPTION...] SRC... [USER@]HOST:DEST
```
при роботі сподівається що на іншій стороні також є встановлений `rsync`, який допоможе йому копіювати "лише змінені частини файлів" тощо.

## ssh-agent (слайд 11)
ssh-agent:
коли ми генерували ключ, там була опція, або крок - задання пароля на ключ. 
як ми бачимо файл приватного ключа є ну і є ключем доступу до сервера. якщо зловмисник заволодіє ключем він зможе отримати доступ до наших ресурсів. 
ми можемо захистити приватнй ключ зашифрував його паролем. і при використанні ключа клієнт запитає пароль. але вводити кожен раз пароль це незручно, саме для того існує ssh-agent.
це фонова програма, яка отримує паролі для ключів, ключі та надає доступ ssh-клієнту до них.

Запуск SSH-Agent:
eval `ssh-agent`
з'являються дві змінні середовища:
SSH_AGENT_PID
SSH_AUTH_SOCK
додавання ключів відбувається так:
ssh-add /path/to/privatekey

доступ до вашого ssh-agent-а можна прокинути на сервер куди ви заходите, це опція -A, і віддалений ssh-клієнт зможе скористуватись вашим ключем без необхідності збергіати ключі на "проміжному сервері" 
такий підхід назівається jumphost або bastion.


ssh-клієнт
аналогічний принцип роботи і при використанні віндовс-агентів наприклад в популярному віндовс-клієнті putty - там є putty pageant


Корисні поради та best practices:

## не розглянуто:
- прокидування портів, тунелювання. це опції -R, -L 
- налаштування authorized-key ключа опції from, command
- gssapi/pam аутентфікація, централізовані публічні ключі, openIPA
